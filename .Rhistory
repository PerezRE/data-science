ylab = "y", pch = 16)
# Realice el gráfico de dispersión de los datos
plot(x,y,pch=16)
# Ajuste un modelo de regresión lineal simple a los datos,
# muestre un resumen del modelo ajustado
# y trace la recta de regresión estimada junto con el gráfico de dispersión
m <- lm(y~x)
summary(m)
plot(x, y, xlab = "x",
ylab = "y", pch = 16)
abline(lsfit(x, y)) # Trazamos la recta de regresión estimada
mtext(expression(paste('Modelo de regresión lineal simple:',
' ',
y[i] == beta[0] + beta[1]*x[i] + e[i])),
side = 3, adj=1, font = 2)
# Obtenga algunas gráficas de diagnóstico y diga si es razonable
# suponer para los errores aleatoriedad, normalidad y varianza constante.
par(mfrow = c(2, 2))
plot(m1)
dev.off()
# Se cree que entre las variables x y y del archivo csv adjunto,
# podría haber una relación más o menos lineal. Para tener más evidencia sobre esto
# lleve a cabo lo siguiente:
data <- read.csv("https://raw.githubusercontent.com/beduExpert/Programacion-con-R-Santander/master/Sesion-05/Reto-01/datoslineal.csv")
attach(data)
# Realice el gráfico de dispersión de los datos
plot(x,y,pch=16)
# Ajuste un modelo de regresión lineal simple a los datos,
# muestre un resumen del modelo ajustado
# y trace la recta de regresión estimada junto con el gráfico de dispersión
m <- lm(y~x)
summary(m)
plot(x, y, xlab = "x",
ylab = "y", pch = 16)
abline(lsfit(x, y)) # Trazamos la recta de regresión estimada
mtext(expression(paste('Modelo de regresión lineal simple:',
' ',
y[i] == beta[0] + beta[1]*x[i] + e[i])),
side = 3, adj=1, font = 2)
# Obtenga algunas gráficas de diagnóstico y diga si es razonable
# suponer para los errores aleatoriedad, normalidad y varianza constante.
par(mfrow = c(2, 2))
plot(m)
dev.off()
# Obtenga algunas gráficas de diagnóstico y diga si es razonable
# suponer para los errores aleatoriedad, normalidad y varianza constante.
anova(m)
summary(m)
summary(m)
# Obtenga algunas gráficas de diagnóstico y diga si es razonable
# suponer para los errores aleatoriedad, normalidad y varianza constante.
anova(m)
par(mfrow = c(2, 2))
plot(m)
install.packages(c("ISLR", "e1071"))
library(e1071)
?Default
install.packages("TSA")
AirPassengers
AP <- AirPassengers
AP
start(AP); end(AP); frequency(AP);
summary(AP)
plot(AP)
plot(AP)
par("mar")
par(mar=c(1,1,1,1))
plot(AP)
par(mar=c(3,2,2,3))
plot(AP)
par(mar=c(5.1, 4.1, 4.1, 2.1))
plot(AP)
plot(AP)
plot(AP)
par(mar=c(4.1, 3.1, 3.1, 1.1))
plot(AP)
install.packages(c("RMySQL", "DBI"))
shynidemo
shinydemo
install.packages("rvest")
# - Extraer la tabla del HTML
theurl <- "https://www.glassdoor.com.mx/Sueldos/data-scientist-sueldo-SRCH_KO0,14.htm"
file <- read_html(theurl)    # Leemos el html
library(rvest)
# - Extraer la tabla del HTML
theurl <- "https://www.glassdoor.com.mx/Sueldos/data-scientist-sueldo-SRCH_KO0,14.htm"
file <- read_html(theurl)    # Leemos el html
file
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
tables <- html_nodes(file, "table")
tables
tables[1]
tables[2]
tables[1]
table1 <- html_table(tables[4], fill = TRUE)
tables
class(tables)
str(tables)
tables
tables[1]
tables[2]
tables[0]
tables[1]
table1 <- html_table(tables[1], fill = TRUE)
table1
table <- na.omit(as.data.frame(table1))   # Quitamos NA´s que meten filas extras y convertimos la lista en un data frame para su manipulación con R
str(table)  # Vemos la naturaleza de las variables
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
file <- gsub("[^0-9.-]", "", file)
tables <- html_nodes(file, "table")
table1 <- html_table(tables[1], fill = TRUE)
table <- na.omit(as.data.frame(table1))   # Quitamos NA´s que meten filas extras y convertimos la lista en un data frame para su manipulación con R
str(table)  # Vemos la naturaleza de las variables
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
head(table)
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
head(table)
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
tables <- html_nodes(file, "table")
file <- read_html(theurl)    # Leemos el html
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
tables <- html_nodes(file, "table")
table1 <- html_table(tables[1], fill = TRUE)
gsub("[^0-9.-]", "", table1)
gsub("[^0-9.-]", "", table1)
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
tables <- html_nodes(file, "table")
table1 <- html_table(tables[1], fill = TRUE)
gsub("[^0-9.-]", "", table1)
table1
table <- na.omit(as.data.frame(table1))   # Quitamos NA´s que meten filas extras y convertimos la lista en un data frame para su manipulación con R
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
gsub("[^0-9.-]", "", table)
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
table$Sueldo
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
gsub("[^A-Za-z.-]", "", table$Sueldo)
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
gsub("[A-Za-z.-]", "", table$Sueldo)
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
gsub("[A-Za-z$.-]", "", table$Sueldo)
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
gsub("[A-Za-z$/.-]", "", table$Sueldo)
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
table$Sueldo <- gsub("[A-Za-z$/.-]", "", table$Sueldo)
table
str(table)
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
table$Sueldo <- as.numeric(gsub("[A-Za-z$/.-]", "", table$Sueldo))
table
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
table$Sueldo <- as.numeric(gsub("[A-Za-z$/,.-]", "", table$Sueldo))
table
file <- read_html(theurl)    # Leemos el html
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
tables <- html_nodes(file, "table")
table1 <- html_table(tables[1], fill = TRUE)
table <- na.omit(as.data.frame(table1))   # Quitamos NA´s que meten filas extras y convertimos la lista en un data frame para su manipulación con R
str(table)  # Vemos la naturaleza de las variables
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
table$Sueldo <- as.numeric(gsub("[A-Za-z$/,.-]", "", table$Sueldo))
table
# Ahora podrás responder esta pregunta ¿Cuál es la empresa que más paga y la que menos paga?
table[which.max(table$Sueldo)]
# Ahora podrás responder esta pregunta ¿Cuál es la empresa que más paga y la que menos paga?
i <- which.max(table$Sueldo)
i
table[i,]
i <- which.min(table$Sueldo)
table[i,]
# RETO 3. Series de tiempo
# Utiliza los datos (AP), de la siguiente librería para realizar lo que se te pide
library(forecast)
data(AirPassengers)
AP <- AirPassengers
# 1. Realiza la gráfica de la serie de tiempo
plot(AP, main = "Serie de tiempo", ylab = "Pasajeros", xlab = "Año")
# 2. Descompón la serie de tiempo en aditiva y multiplicativa y realiza sus gráficas
## Gráfica aditiva
APA <- decompose(AP, type = "additive")
APM <- decompose(AP, type = "multiplicative")
plot(APA$trend, main = "Tendencia", ylab = "Tendencia", xlab = "Año")  # Gráfica de la tendencia
plot(APA$seasonal, main = "Estacionalidad", ylab = "Tendencia", xlab = "Año") # Gráfica de la estacionalidad
## Gráfica multiplicativa
plot(APM$trend, main = "Tendencia", ylab = "Tendencia", xlab = "Año")
plot(APM$seasonal, main = "Estacionalidad", ylab = "Tendencia", xlab = "Año")
# 3. Realiza la gráfica de la descomposición aditiva con la tendencia y la estacionalidad utilizando el comando lines
plot(APA$trend , main  = "Multiplicativa", ylab = "Tendencia", xlab = "Año")
lines(APA$seasonal * APA$trend, col = 4, lty = 1, lwd = 1)
# 4. Realiza la gráfica de la descomposición multiplicativa con la tendencia y la estacionalidad utilizando el comando lines
plot(APM$trend , main  = "Multiplicativa", ylab = "Tendencia", xlab = "Año")
lines(APM$seasonal * APM$trend, col = 2, lty = 1, lwd = 1)
# RETO 3. Series de tiempo
# Utiliza los datos (AP), de la siguiente librería para realizar lo que se te pide
library(forecast)
data(AirPassengers)
AP <- AirPassengers
# 1. Realiza la gráfica de la serie de tiempo
plot(AP, main = "Serie de tiempo", ylab = "Pasajeros", xlab = "Año")
# 2. Descompón la serie de tiempo en aditiva y multiplicativa y realiza sus gráficas
## Gráfica aditiva
APA <- decompose(AP, type = "additive")
APM <- decompose(AP, type = "multiplicative")
plot(APA$trend, main = "Tendencia", ylab = "Tendencia", xlab = "Año")  # Gráfica de la tendencia
plot(APA$seasonal, main = "Estacionalidad", ylab = "Tendencia", xlab = "Año") # Gráfica de la estacionalidad
## Gráfica multiplicativa
plot(APM$trend, main = "Tendencia", ylab = "Tendencia", xlab = "Año")
plot(APM$seasonal, main = "Estacionalidad", ylab = "Tendencia", xlab = "Año")
# 3. Realiza la gráfica de la descomposición aditiva con la tendencia y la estacionalidad utilizando el comando lines
plot(APA$trend , main  = "Aditiva", ylab = "Tendencia", xlab = "Año")
lines(APA$seasonal * APA$trend, col = 4, lty = 1, lwd = 1)
# 4. Realiza la gráfica de la descomposición multiplicativa con la tendencia y la estacionalidad utilizando el comando lines
plot(APM$trend , main  = "Multiplicativa", ylab = "Tendencia", xlab = "Año")
lines(APM$seasonal * APM$trend, col = 2, lty = 1, lwd = 1)
library(rvest)
# De la siguiente dirección donde se muestran los sueldos para Data Scientists
# (https://www.glassdoor.com.mx/Sueldos/data-scientist-sueldo-SRCH_KO0,14.htm), realiza las siguientes acciones:
# - Extraer la tabla del HTML
theurl <- "https://www.glassdoor.com.mx/Sueldos/data-scientist-sueldo-SRCH_KO0,14.htm"
file <- read_html(theurl)    # Leemos el html
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
tables <- html_nodes(file, "table")
table1 <- html_table(tables[1], fill = TRUE)
table <- na.omit(as.data.frame(table1))   # Quitamos NA´s que meten filas extras y convertimos la lista en un data frame para su manipulación con R
str(table)  # Vemos la naturaleza de las variables
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
table$Sueldo <- as.numeric(gsub("[A-Za-z$/,.-]", "", table$Sueldo))
# Ahora podrás responder esta pregunta ¿Cuál es la empresa que más paga y la que menos paga?
i <- which.max(table$Sueldo)
table[i,]
i <- which.min(table$Sueldo)
table[i,]
file <- read_html(theurl)    # Leemos el html
library(rvest)
# - Extraer la tabla del HTML
theurl <- "https://www.glassdoor.com.mx/Sueldos/data-scientist-sueldo-SRCH_KO0,14.htm"
file <- read_html(theurl)    # Leemos el html
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
tables <- html_nodes(file, "table")
tables
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
file
# - Quitar los caracteres no necesarios de la columna sueldos (todo lo que no sea número),
#   para dejar solamente la cantidad mensual (Hint: la función gsub podría ser de utilidad).
tables <- html_nodes(file, "table")
tables
tabble[0]
table[0]
table[1]
tables[0]
tables[1]
table1
str(table1)
table <- na.omit(as.data.frame(table1))   # Quitamos NA´s que meten filas extras y convertimos la lista en un data frame para su manipulación con R
str(table)  # Vemos la naturaleza de las variables
# - Asignar ésta columna como tipo numérico para poder realizar operaciones con ella
table$Sueldo <- as.numeric(gsub("[A-Za-z$/,.-]", "", table$Sueldo))
# Ahora podrás responder esta pregunta ¿Cuál es la empresa que más paga y la que menos paga?
i <- which.max(table$Sueldo)
table[i,]
i <- which.min(table$Sueldo)
table[i,]
setwd("~/workspace/courses/bedu/modulo 2/datascience")
videogames <- na.omit(read.csv("https://raw.githubusercontent.com/PerezRE/datascience/main/Proyecto/data/dataset.csv", header=TRUE))
select_if(is.logical)
videogames %>% select_if(is.logical)
library(dyplr)
library(ggplot2)
videogames %>% select_if(is.logical)
videogames %>% select(starts_with("Petal"))
library(dplyr)
library(ggplot2)
videogames %>% select_if(is.logical)
# videogames %>% select_if(is.logical)
videogames %>% select(starts_with("Categorie"))
# videogames %>% select_if(is.logical)
categories <- videogames %>% select(starts_with("Categorie"))
lapply(categories[,cols], as.numeric)
lapply(categories[,colnames(categories)], as.numeric)
cateogires <- lapply(categories[,colnames(categories)], as.numeric)
# videogames %>% select_if(is.logical)
categories <- videogames %>% select(starts_with("Categorie"))
cateogires <- na.omit(lapply(categories[,colnames(categories)], as.numeric))
cateogires <- complete.cases(na.omit(lapply(categories[,colnames(categories)], as.numeric)))
cateogires <- na.omit(lapply(categories[,colnames(categories)], as.numeric))
cateogires
length(cateogires)
videogames <- na.omit(read.csv("https://raw.githubusercontent.com/PerezRE/datascience/main/Proyecto/data/dataset.csv", header=TRUE))
# videogames %>% select_if(is.logical)
categories <- videogames %>% select(starts_with("Categorie"))
cateogires <- na.omit(lapply(categories[,colnames(categories)], as.numeric))
length(cateogires)
runif(length(categories), min=0, max=1)
floor(runif(length(categories), min=0, max=1))
floor(runif(length(categories), min=0, max=1))
floor(runif(length(categories), min=0, max=1))
floor(runif(length(categories), min=0, max=2))
floor(runif(length(categories), min=0, max=2))
# Entrada simualada
input <- floor(runif(length(categories), min=0, max=2))
# Videogames %>% select_if(is.logical)
categories <- videogames %>% select(starts_with("Categorie"))
categories <- na.omit(lapply(categories[,colnames(categories)], as.numeric))
videogames <- na.omit(read.csv("https://raw.githubusercontent.com/PerezRE/datascience/main/Proyecto/data/dataset.csv", header=TRUE))
# Videogames %>% select_if(is.logical)
categories <- videogames %>% select(starts_with("Categorie"))
categories <- na.omit(lapply(categories[,colnames(categories)], as.numeric))
# Entrada simualada de generos.
input <- floor(runif(length(categories), min=0, max=2))
# videogames %>% select(starts_with("Genre"))
categories
str(categories)
videogames <- na.omit(read.csv("https://raw.githubusercontent.com/PerezRE/datascience/main/Proyecto/data/dataset.csv", header=TRUE))
# Seleccionar las variables definidas para categorias.
categories <- videogames %>% select(starts_with("Categorie"))
# Convertir de tipo lógico a númerico.
categories <- na.omit(lapply(categories[,colnames(categories)], as.numeric))
str(categories)
# videogames %>% select(starts_with("Genre"))
categories <- categories[,-c("categories")]
# videogames %>% select(starts_with("Genre"))
categories <- categories[,-"categories"]
# videogames %>% select(starts_with("Genre"))
categories[,!(names("categories") %in% categories)]
# videogames %>% select(starts_with("Genre"))
categories[, !(names("categories") %in% "categories")]
# videogames %>% select(starts_with("Genre"))
categories[, !(names("Categories") %in% "categories")]
# videogames %>% select(starts_with("Genre"))
categories[ , -which(names("categories") %in% c("categories"))]
library(dplyr)
# videogames %>% select(starts_with("Genre"))
categories[ , -which(names("categories") %in% c("categories"))]
# videogames %>% select(starts_with("Genre"))
str(categories)
sapply(categories, cos_sim)
#  Obtiene el vector normal
norm_vec <- function(x) sqrt(sum(x^2))
cos_sim <- function(a, b) {
norm_a <- norm_vec(a)
norm_b <- norm_vec(b)
# 0 no similitud | 1 similitud
return(dot(a, b) / (norm_a * norm_b))
}
sapply(categories, cos_sim)
sapply(categories, cos_sim, var2 = input)
# Entrada simualada de generos.
input <- floor(runif(length(categories), min=0, max=2))
sapply(categories, cos_sim, var2 = input)
transpose(categories)
library(data.table)
transpose(categories)
head(transpose(categories))
for (i in colnames(categories)){
print(class(categories[[i]]))
}
print(class(categories[[i]]))
for (i in colnames(categories)){
print(class(categories[[i]]))
}
# Entrada simualada de generos.
input <- floor(runif(length(categories), min=0, max=2))
for (i in colnames(categories)){
print(class(categories[[i]]))
}
print(i)
print(categories[,i])
print(categories[i,])
for (i in colnames(categories)){
print("asdasd")
}
dt <- iris
for (i in colnames(dt)){
print(class(df[[i]]))
}
print(class(df[i]))
names(categories)
print("ok")
for (i in names(categories)){
print("ok")
}
for (i in names(categories)){
print("asdasd")
}
print(categories[,i])
print(categories[i,])
print(categories[[i]])
for (i in names(categories)){
categorie_values <- categories[[i]]
print(cos_sim(input, categorie_values))
}
library(geometry)
install.packages("geometry")
for (i in names(categories)){
categorie_values <- categories[[i]]
print(cos_sim(input, categorie_values))
}
library(geometry)
print(cos_sim(input, categorie_values))
length(categorie_values)
for (i in names(categories)){
categorie_values <- categories[[i]]
length(categorie_values)
length(input)
#print(cos_sim(input, categorie_values))
}
for (i in names(categories)){
categorie_values <- categories[[i]]
length(categorie_values)
length(input)
#print(cos_sim(input, categorie_values))
}
categorie_values <- categories[[i]]
length(categorie_values)
length(input)
categorie_values
i
print(i)
for (i in categories){
print(i)
length(input)
# print(cos_sim(input, categorie_values))
}
print(length(i))
# Seleccionar las variables definidas para categorias.
categories <- videogames %>% select(starts_with("Categorie"))
# Convertir de tipo lógico a númerico.
categories <- na.omit(lapply(categories[,colnames(categories)], as.numeric))
# Seleccionar las variables definidas para categorias.
categories <- videogames %>% select(starts_with("Categorie"))
# Convertir de tipo lógico a númerico.
categories <- na.omit(lapply(categories[,colnames(categories)], as.numeric))
head(categories)
library(dplyr)
library(ggplot2)
library(geometry)
library(data.table)
#  Vector normal
norm_vec <- function(x) sqrt(sum(x^2))
cos_sim <- function(a, b) {
norm_a <- norm_vec(a)
norm_b <- norm_vec(b)
# 0 no similitud | 1 similitud
return(dot(a, b) / (norm_a * norm_b))
}
videogames <- na.omit(read.csv("https://raw.githubusercontent.com/PerezRE/datascience/main/Proyecto/data/dataset.csv", header=TRUE))
# Seleccionar las variables definidas para categorias.
categories <- videogames %>% select(starts_with("Categorie"))
# Convertir de tipo lógico a númerico.
categories <- na.omit(lapply(categories[, colnames(categories)], as.numeric))
categories$categories <- NULL # Eliminar columna  de NA's generadas en el paso anterior.
# Entrada simualada de generos.
input <- floor(runif(length(categories), min=0, max=2))
for (i in categories){
length(input)
# print(cos_sim(input, categorie_values))
}
length(input)
#length(input)
print(cos_sim(input, categorie_values))
#length(input)
length(i)
length(categories)
# length(input)
length(i)
print(i)
length(i)
length(i)
head(categories); str(categories);
length(row)
length(categories[row,])
length(categories[row, ])
length(categories[row, ])
length(categories[row, colnames(categories)])
row <- categories[i,]
length(i)
apply(categories, cos_sim)
library(dplyr)
library(ggplot2)
library(tidyverse)
# Leemos los datos
videogames <- na.omit(read.csv("https://raw.githubusercontent.com/PerezRE/datascience/main/Proyecto/data/dataset.csv", header=TRUE))
videogames <- videogames %>% filter(genre_Indie=TRUE)
videogames <- na.omit(videogames)
videogames <- videogames[!duplicated(videogames$name),]
videogames <- videogames %>% mutate(release_date = as.Date(release_date, format = "%Y-%m-%d"))
videogames <- arrange(videogames, release_date)
names(videogames)
#=================== ¿Qué videojuego ha sido el más/menos jugado?==========================
columns <- c("name", "release_date", "average_playtime", "median_playtime")
#Menos jugado tomando el promedio
videogames[which.min(filter(videogames,average_playtime>0)$average_playtime), columns]
#Mas jugado tomando el promedio
videogames[which.max(videogames$average_playtime), columns]
#El menos jugado tomando la media
videogames[which.min(filter(videogames,median_playtime>0)$median_playtime), columns]
#El mas jugado tomando la media
videogames[which.max(videogames$median_playtime), columns]
columns <- c("name", "positive_ratings", "negative_ratings", "release_date")
videogames[which.min(videogames$positive_ratings), columns]
videogames[which.min(videogames$negative_ratings), columns]
videogames[which.max(videogames$positive_ratings), columns]
videogames[which.max(videogames$negative_ratings), columns]
